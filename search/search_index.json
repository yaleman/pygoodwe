{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pygoodwe","text":"<p>A command line tool and python library to query the GOODWE SEMS Portal APIs.</p>"},{"location":"#api-docs","title":"API Docs","text":"<p>Auto-generated documentation is here: https://yaleman.github.io/pygoodwe/</p>"},{"location":"#installation","title":"Installation","text":"<p>You need to have Python 3 and pip installed. Then:</p> <pre><code>python -m pip install pygoodwe\n</code></pre> <p>Determine the Station ID from the GOODWE site as follows. Open the Sems Portal. The Plant Status will reveal the Station ID in the URL. Example:</p> <pre><code>https://www.semsportal.com/powerstation/powerstatussnmin/11112222-aaaa-bbbb-cccc-ddddeeeeeffff\n</code></pre> <p>Then the Station ID is <code>11112222-aaaa-bbbb-cccc-ddddeeeeeffff</code>.</p> <p>To use example.py or the other examples, copy config.py.example to config.py and add your details.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Please feel free to lodge an issue or pull request on GitHub.</p>"},{"location":"#thanks","title":"Thanks","text":"<ul> <li>Originally based off the work of Mark Ruys and his gw2pvo software - I needed something more flexible, so I made this.</li> </ul>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>GOODWE access is based on the undocumented API used by mobile apps. This could break at any time.</p>"},{"location":"#example-code","title":"Example Code","text":"<p>Please check out example.py or the examples folder in the project repository for some simple example code.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<ul> <li>0.0.1 - 0.0.3 2019-10-09 Initial versions, basically just getting packaging and the most simple things working</li> <li>0.0.4 2019-10-09 Fixed a bug that mis-identified the load generating power.</li> <li>0.0.5 2019-10-09 Updated setup.py to build in a requirement for <code>requests</code></li> <li>0.0.6-0.0.7 2019-10-12 Updated SingleInverter to return battery state of charge, then fixed the fact I was implementing the same thing two different ways...</li> <li>0.0.8 2019-10-12 I really should write some tests for this. Fixed SingleInverter.get_battery_soc() to actually work.</li> <li>0.0.9 2019-10-12 Catching an error when the inverter data doesn't load.</li> <li>0.0.10 ... not sure?</li> <li>0.0.11 2019-11-05 Commented out some non-functional code.</li> <li>0.0.12 2019-12-03 Removed the non-used code, fixed a bug.</li> <li>0.0.13 2020-06-22 Added getPmeter from community submission, fixed a lot of pylint errors</li> <li>0.0.14 2020-07-06 Updated API endpoint due to cert expiry/change of API from 'https://globalapi.sems.com.cn/api/'' to 'https://semsportal.com/api/' as the old one was throwing expired cert errors.</li> <li>0.0.16 2021-02-04 Included option from Peter Verthez to download an Excel file of data, cleaned up some old code style mess.</li> <li>0.0.17 2022-06-04 Fully typed, if a little janky, replaced flit packaging with uv run.</li> <li>0.0.18 2022-06-28 Added mkdocs automagical documentation, bumped version to update details on pypi.</li> <li>0.1.0 2022-10-05 Fixed issue with getDataPvoutput on SingleInverters. (#148)</li> <li>0.1.2 2022-12-19 Updating SEMS API Endpoints to V2.</li> <li>0.1.3 2022-12-29 Removed an extra error message.</li> <li>0.1.4 2022-12-30 XLS Export fixes</li> <li>0.1.5 2023-01-04 Fixes for get_current_readings to pass settings down properly, and do less double-error-handling.</li> <li>0.1.7 2024-01-15 Adding login error handling and dependency updates.</li> <li>0.1.9 2025-02-25 Moving to uv for package management.</li> <li>0.1.10 2025-09-19 Fix #356 - Handle Chinese success message in Excel endpoint, package updates.</li> <li>0.1.11 2026-01-28 Minimum Python raised to 3.12.</li> </ul>"},{"location":"pygoodwe/","title":"API Documentation","text":"<p>pygoodwe: a (terrible) interface to the goodwe solar API</p>"},{"location":"pygoodwe/#pygoodwe.API","title":"<code>API</code>","text":"<p>API implementation</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>class API:\n    \"\"\"API implementation\"\"\"\n\n    # pylint: disable=too-many-instance-attributes,too-many-arguments\n    def __init__(\n        self,\n        system_id: str,\n        account: str,\n        password: str,\n        api_url: str = API_URL,\n        log_level: Optional[str] = None,\n        user_agent: str = DEFAULT_UA,\n        skipload: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Options:\n\n        skipload: don't run self.getCurrentReadings() on init\n        api_url: you can change the API endpoint it hits\n        \"\"\"\n        # TODO: lang: Real Soon Now it'll filter out any responses without that language\n\n        self.data: Dict[str, Any] = {}\n\n        if log_level is None:\n            if \"LOG_LEVEL\" in os.environ:\n                log_level = os.environ[\"LOG_LEVEL\"]\n            else:\n                log_level = \"INFO\"\n\n        if log_level in (\"DEBUG\", \"INFO\", \"WARNING\"):\n            log_level = getattr(logging, os.getenv(\"LOG_LEVEL\", \"INFO\"))\n            logging.basicConfig(\n                level=log_level,\n            )\n        self.session = Session()\n        self.system_id = system_id\n        self.account = account\n        self.password = password\n        self.token = '{\"version\":\"v2.0.4\",\"client\":\"ios\",\"language\":\"en\"}'\n        self.global_url = api_url\n        self.base_url = self.global_url\n\n        logging.debug(\"API URL: %s\", self.base_url)\n\n        self.user_agent = user_agent\n\n        if skipload:\n            logging.debug(\"Skipping initial load of data\")\n        else:\n            logging.debug(\"Doing load of data\")\n            self.getCurrentReadings(raw=True)\n\n    def loaddata(self, filename: str) -&gt; None:\n        \"\"\"loads a json file of existing data\"\"\"\n        with open(filename, \"r\", encoding=\"utf8\") as filehandle:\n            self.data = json.loads(filehandle.read())\n\n    _loaddata = loaddata\n\n    def get_current_readings(\n        self,\n        raw: bool = True,\n        retry: int = 1,\n        maxretries: int = 5,\n        delay: int = 30,\n    ) -&gt; Dict[str, Any]:  # pylint: disable=invalid-name\n        \"\"\"gets readings at the current point in time\"\"\"\n        payload = {\"powerStationId\": self.system_id}\n\n        # GOODWE server\n        self.data = self.call(\"v2/PowerStation/GetMonitorDetailByPowerstationId\", payload)\n\n        retval = self.data\n\n        if not self.data.get(\"inverter\"):\n            if retry &lt; maxretries:\n                logging.error(\"no inverter data, try %s, trying again in %s seconds\", retry, delay)\n                time.sleep(delay)\n                return self.get_current_readings(raw=raw, retry=retry + 1, maxretries=maxretries, delay=delay)\n            logging.error(\"No inverter data after %s retries, quitting.\", retry)\n            sys.exit(f\"No inverter data after {retry} retries, quitting.\")\n        return retval\n\n    # stub function names to old names\n    getCurrentReadings = get_current_readings\n\n    # def getDayReadings(self, date):\n    #     date_s = date.strftime('%Y-%m-%d')\n    #     payload = {\n    #         'powerStationId' : self.system_id\n    #     }\n    #     data = self.call(\"v2/PowerStation/GetMonitorDetailByPowerstationId\", payload)\n    #     if 'info' not in data:\n    #     logging.warning(date_s + \" - Received bad data \" + str(data))\n    #         return result\n    #     result = {\n    #         'latitude' : data['info'].get('latitude'),\n    #         'longitude' : data['info'].get('longitude'),\n    #         'entries' : []\n    #     }\n    #     payload = {\n    #         'powerstation_id' : self.system_id,\n    #         'count' : 1,\n    #         'date' : date_s\n    #     }\n    #     data = self.call(\"PowerStationMonitor/GetPowerStationPowerAndIncomeByDay\", payload)\n    #     if len(data) == 0:\n    #         logging.warning(date_s + \" - Received bad data \" + str(data))\n    #         return result\n    #     eday_kwh = data[0]['p']\n    #     payload = {\n    #         'id' : self.system_id,\n    #         'date' : date_s\n    #     }\n    #     data = self.call(\"PowerStationMonitor/GetPowerStationPacByDayForApp\", payload)\n    #     if 'pacs' not in data:\n    #         logging.warning(date_s + \" - Received bad data \" + str(data))\n    #         return result\n    #     minutes = 0\n    #     eday_from_power = 0\n    #     for sample in data['pacs']:\n    #         parsed_date = datetime.strptime(sample['date'], \"%m/%d/%Y %H:%M:%S\")\n    #         next_minutes = parsed_date.hour * 60 + parsed_date.minute\n    #         sample['minutes'] = next_minutes - minutes\n    #         minutes = next_minutes\n    #         eday_from_power += sample['pac'] * sample['minutes']\n    #     factor = eday_kwh / eday_from_power if eday_from_power &gt; 0 else 1\n    #     eday_kwh = 0\n    #     for sample in data['pacs']:\n    #         date += timedelta(minutes=sample['minutes'])\n    #         pgrid_w = sample['pac']\n    #         increase = pgrid_w * sample['minutes'] * factor\n    #         if increase &gt; 0:\n    #             eday_kwh += increase\n    #             result['entries'].append({\n    #                 'dt' : date,\n    #                 'pgrid_w': pgrid_w,\n    #                 'eday_kwh': round(eday_kwh, 3)\n    #             })\n    #     return result\n\n    @property\n    def headers(self) -&gt; Dict[str, str]:\n        \"\"\"request headers\"\"\"\n        return {\n            \"User-Agent\": self.user_agent,\n            \"Token\": self.token,\n        }\n\n    # pylint: disable=invalid-name\n    def getDayDetailedReadingsExcel(\n        self,\n        export_date: date,\n        timeout: int = 10,\n        filename: Optional[str] = None,\n    ) -&gt; bool:\n        \"\"\"retrieves the detailed daily results of the given date as an Excel sheet,\n        processing the Excel sheet is outside the scope of the current module,\n        possible args:\n        - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls\n        \"\"\"\n        datestr = export_date.strftime(\"%Y-%m-%d\")\n        if filename is None:\n            filename = f\"Plant_Power_{datestr}.xls\"\n        logging.debug(\"Will write data for %s to file: %s\", datestr, filename)\n\n        uri = \"v1/PowerStation/ExportPowerstationPac\"\n        # {\"api\":\"v2/PowerStation/ExportPowerstationPac\",\"param\":{\"date\":\"2021-12-20\",\"pw_id\":\"&lt;my-pw-id&gt;\"\n        payload_export = {\n            \"date\": datestr,\n            \"pw_id\": self.system_id,\n        }\n\n        data = self.call(uri, payload=payload_export)\n\n        payload_get_url = {\"id\": data}\n        get_url_uri = \"v1/ReportData/GetStationPowerDataFilePath\"\n        data = self.call(get_url_uri, payload=payload_get_url)\n\n        file_url = data.get(\"file_path\")\n        if file_url is None:\n            logging.error(\"Failed to get file path from \")\n            return False\n\n        response = requests.get(file_url, timeout=timeout)\n        response.raise_for_status()\n\n        try:\n            file_download_path = Path(filename)\n            file_download_path.write_bytes(response.content)\n        except Exception as error_message:  # pylint: disable=broad-except\n            logging.error(\"Failed to write file %s! Error: %s\", filename, error_message)\n            return False\n        return True\n\n    def do_login(self, timeout: int = 10) -&gt; bool:\n        \"\"\"does the login and token saving thing\"\"\"\n        login_payload = {\n            \"account\": self.account,\n            \"pwd\": self.password,\n        }\n        try:\n            response = self.session.post(\n                self.global_url + \"v2/Common/CrossLogin\",\n                headers=self.headers,\n                data=login_payload,\n                timeout=timeout,\n            )\n            response.raise_for_status()\n        except requests.exceptions.RequestException as exp:\n            logging.error(\"RequestException during do_login(): %s\", exp)\n            print(f\"{exp=}\")\n            return False\n\n        data = response.json()\n        if data.get(\"code\") != 0:\n            logging.error(\"Failed to log in: %s\", data.get(\"msg\"))\n            print(f\"{data=}\")\n            return False\n\n        if data.get(\"api\"):\n            logging.debug(\"Setting base url to %s\", data.get(\"api\"))\n            self.base_url = data.get(\"api\")\n        self.token = json.dumps(data.get(\"data\"))\n        logging.debug(\"Done login, token: %s\", self.token)\n        return True\n\n    def call(\n        self,\n        url: str,\n        payload: Any,\n        max_tries: int = 3,\n        timeout: int = 10,\n    ) -&gt; Dict[str, Any]:  # pylint: disable=unused-argument\n        \"\"\"makes a call to the API\"\"\"\n        for i in range(1, max_tries):\n            try:\n                logging.debug(\n                    \"Pulling the following URL: base_url='%s', url='%s'\",\n                    self.base_url,\n                    url,\n                )\n                response = self.session.post(\n                    self.base_url + url,\n                    headers=self.headers,\n                    data=payload,\n                    timeout=timeout,\n                )\n                response.raise_for_status()\n                data = response.json()\n                logging.debug(\"call response.json(): %s\", json.dumps(data))\n\n                # APIs return \"success\", \"Success\", \"Successful\" in the 'msg'\n                # seen \"Successful\" in ExportPowerStationPac\n                if data.get(\"msg\", \"\").lower() in SUCCESS_MESSAGES and \"data\" in data:  # pylint: disable=no-else-return\n                    logging.debug(\"Returning data: %s\", json.dumps(data[\"data\"], default=str))\n                    result: Dict[str, Any] = data.get(\"data\")\n                    return result\n                logging.debug(json.dumps(data))\n\n                logging.debug(\"Logging in again...\")\n                if not self.do_login():\n                    logging.error(\"Failed to log in, bailing\")\n                    return {}\n            except requests.exceptions.RequestException as exp:\n                logging.error(\"RequestException: %s\", exp)\n            logging.debug(\"Sleeping for %s seconds...\", i)\n            time.sleep(i)\n\n        logging.error(\"Failed to call GoodWe API url='%s'\", self.base_url + url)\n        return {}\n\n    @classmethod\n    def parseValue(cls, value: str, unit: str) -&gt; float:  # pylint: disable=invalid-name\n        \"\"\"takes a string value and reutrns it as a float (if possible)\"\"\"\n        try:\n            return float(value.rstrip(unit))\n        except ValueError as exp:\n            logging.warning(\"ValueError: %s\", exp)\n            return 0.0\n\n    def are_batteries_full(self, fullstate: float = 100.0) -&gt; bool:\n        \"\"\"boolean result for if the batteries are full. you can set your given 'full'\n        percentage in float if you want to lower this a little\n        are_batteries_full(fullstate=90.0): returns bool\n        \"\"\"\n        soc = self.get_batteries_soc()\n        if not isinstance(soc, list):\n            if soc &gt;= fullstate:\n                return True\n            return False\n\n        for battery in soc:\n            if battery &lt; fullstate:\n                return False\n        return True\n\n    def _get_batteries_soc(self) -&gt; Union[List[float], float]:\n        \"\"\"returns a list of the state of charge for the batteries\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        if \"inverter\" not in self.data:\n            raise ValueError(\"Couldn't get data...\")\n        return [float(inverter.get(\"invert_full\", {}).get(\"soc\")) for inverter in self.data[\"inverter\"]]\n\n    def get_batteries_soc(self) -&gt; Union[List[float], float]:\n        \"\"\"return the battery state of charge\"\"\"\n        return self._get_batteries_soc()\n\n    def getPVFlow(self) -&gt; float:  # pylint: disable=invalid-name\n        \"\"\"PV flow data\"\"\"\n        raise NotImplementedError(\"SingleInverter has this, multi does not\")\n\n    def getVoltage(self) -&gt; Union[List[float], float]:  # pylint: disable=invalid-name\n        \"\"\"returns the a list of the first AC channel voltages\"\"\"\n        if not self.data:\n            self.getCurrentReadings(True)\n        if \"inverter\" not in self.data:\n            raise ValueError(\"Couldn't get data...\")\n        return [float(inverter.get(\"invert_full\", {}).get(\"vac1\")) for inverter in self.data[\"inverter\"]]\n\n    def getPmeter(self) -&gt; float:  # pylint: disable=invalid-name\n        \"\"\"gets the current line pmeter\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return float(self.data.get(\"inverter\", {}).get(\"invert_full\", {}).get(\"pmeter\"))\n\n    def getLoadFlow(self) -&gt; Union[List[float], float]:  # pylint: disable=invalid-name\n        \"\"\"returns the list of inverter multi-unit load watts\"\"\"\n        raise NotImplementedError(\"multi-unit load watts isn't implemented yet\")\n\n    def get_inverter_temperature(self) -&gt; Union[List[float], float]:\n        \"\"\"returns the list of inverter temperatures\"\"\"\n        if not self.data:\n            self.get_current_readings(True)\n        if \"inverter\" not in self.data:\n            raise ValueError(\"Couldn't get data...\")\n        return [float(inverter.get(\"invert_full\", {}).get(\"tempperature\")) for inverter in self.data[\"inverter\"]]\n\n    def getDataPvoutput(\n        self,\n    ) -&gt; Dict[str, Union[str, float]]:  # pylint: disable=invalid-name\n        \"\"\"updates and returns the data necessary for a one-shot pvoutput upload\n        'd' : testdate.strftime(\"%Y%m%d\"),\n        't' : testtime.strftime(\"%H:%M\"),\n        'v2' : 500, # power generation\n        'v4' : 450,\n        'v5' : 23.5, # temperature\n        'v6' : 234.0, # voltage\n        \"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        # \"time\": \"10/04/2019 14:37:29\"\n        timestamp = datetime.strptime(self.data.get(\"info\", {}).get(\"time\"), \"%m/%d/%Y %H:%M:%S\")\n        data: Dict[str, Union[str, float]] = {}\n        data[\"d\"] = timestamp.strftime(\"%Y%m%d\")  # date\n        data[\"t\"] = timestamp.strftime(\"%H:%M\")  # time\n        data[\"v2\"] = self.getPVFlow()  # PV Generation\n\n        load_flow = self.getLoadFlow()\n        if isinstance(load_flow, list):\n            data[\"v4\"] = load_flow[0]  # power consumption\n        else:\n            data[\"v4\"] = load_flow\n        temp = self.get_inverter_temperature()\n        if isinstance(temp, list):\n            data[\"v5\"] = temp[0]  # inverter temperature\n        else:\n            data[\"v5\"] = temp\n\n        voltage = self.getVoltage()\n        if isinstance(voltage, list):\n            data[\"v6\"] = voltage[0]\n        else:\n            data[\"v6\"] = voltage\n        return data\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.headers","title":"<code>headers</code>  <code>property</code>","text":"<p>request headers</p>"},{"location":"pygoodwe/#pygoodwe.API.__init__","title":"<code>__init__(system_id, account, password, api_url=API_URL, log_level=None, user_agent=DEFAULT_UA, skipload=False)</code>","text":"<p>Options:</p> <p>skipload: don't run self.getCurrentReadings() on init api_url: you can change the API endpoint it hits</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def __init__(\n    self,\n    system_id: str,\n    account: str,\n    password: str,\n    api_url: str = API_URL,\n    log_level: Optional[str] = None,\n    user_agent: str = DEFAULT_UA,\n    skipload: bool = False,\n) -&gt; None:\n    \"\"\"\n    Options:\n\n    skipload: don't run self.getCurrentReadings() on init\n    api_url: you can change the API endpoint it hits\n    \"\"\"\n    # TODO: lang: Real Soon Now it'll filter out any responses without that language\n\n    self.data: Dict[str, Any] = {}\n\n    if log_level is None:\n        if \"LOG_LEVEL\" in os.environ:\n            log_level = os.environ[\"LOG_LEVEL\"]\n        else:\n            log_level = \"INFO\"\n\n    if log_level in (\"DEBUG\", \"INFO\", \"WARNING\"):\n        log_level = getattr(logging, os.getenv(\"LOG_LEVEL\", \"INFO\"))\n        logging.basicConfig(\n            level=log_level,\n        )\n    self.session = Session()\n    self.system_id = system_id\n    self.account = account\n    self.password = password\n    self.token = '{\"version\":\"v2.0.4\",\"client\":\"ios\",\"language\":\"en\"}'\n    self.global_url = api_url\n    self.base_url = self.global_url\n\n    logging.debug(\"API URL: %s\", self.base_url)\n\n    self.user_agent = user_agent\n\n    if skipload:\n        logging.debug(\"Skipping initial load of data\")\n    else:\n        logging.debug(\"Doing load of data\")\n        self.getCurrentReadings(raw=True)\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.are_batteries_full","title":"<code>are_batteries_full(fullstate=100.0)</code>","text":"<p>boolean result for if the batteries are full. you can set your given 'full' percentage in float if you want to lower this a little are_batteries_full(fullstate=90.0): returns bool</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def are_batteries_full(self, fullstate: float = 100.0) -&gt; bool:\n    \"\"\"boolean result for if the batteries are full. you can set your given 'full'\n    percentage in float if you want to lower this a little\n    are_batteries_full(fullstate=90.0): returns bool\n    \"\"\"\n    soc = self.get_batteries_soc()\n    if not isinstance(soc, list):\n        if soc &gt;= fullstate:\n            return True\n        return False\n\n    for battery in soc:\n        if battery &lt; fullstate:\n            return False\n    return True\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.call","title":"<code>call(url, payload, max_tries=3, timeout=10)</code>","text":"<p>makes a call to the API</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def call(\n    self,\n    url: str,\n    payload: Any,\n    max_tries: int = 3,\n    timeout: int = 10,\n) -&gt; Dict[str, Any]:  # pylint: disable=unused-argument\n    \"\"\"makes a call to the API\"\"\"\n    for i in range(1, max_tries):\n        try:\n            logging.debug(\n                \"Pulling the following URL: base_url='%s', url='%s'\",\n                self.base_url,\n                url,\n            )\n            response = self.session.post(\n                self.base_url + url,\n                headers=self.headers,\n                data=payload,\n                timeout=timeout,\n            )\n            response.raise_for_status()\n            data = response.json()\n            logging.debug(\"call response.json(): %s\", json.dumps(data))\n\n            # APIs return \"success\", \"Success\", \"Successful\" in the 'msg'\n            # seen \"Successful\" in ExportPowerStationPac\n            if data.get(\"msg\", \"\").lower() in SUCCESS_MESSAGES and \"data\" in data:  # pylint: disable=no-else-return\n                logging.debug(\"Returning data: %s\", json.dumps(data[\"data\"], default=str))\n                result: Dict[str, Any] = data.get(\"data\")\n                return result\n            logging.debug(json.dumps(data))\n\n            logging.debug(\"Logging in again...\")\n            if not self.do_login():\n                logging.error(\"Failed to log in, bailing\")\n                return {}\n        except requests.exceptions.RequestException as exp:\n            logging.error(\"RequestException: %s\", exp)\n        logging.debug(\"Sleeping for %s seconds...\", i)\n        time.sleep(i)\n\n    logging.error(\"Failed to call GoodWe API url='%s'\", self.base_url + url)\n    return {}\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.do_login","title":"<code>do_login(timeout=10)</code>","text":"<p>does the login and token saving thing</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def do_login(self, timeout: int = 10) -&gt; bool:\n    \"\"\"does the login and token saving thing\"\"\"\n    login_payload = {\n        \"account\": self.account,\n        \"pwd\": self.password,\n    }\n    try:\n        response = self.session.post(\n            self.global_url + \"v2/Common/CrossLogin\",\n            headers=self.headers,\n            data=login_payload,\n            timeout=timeout,\n        )\n        response.raise_for_status()\n    except requests.exceptions.RequestException as exp:\n        logging.error(\"RequestException during do_login(): %s\", exp)\n        print(f\"{exp=}\")\n        return False\n\n    data = response.json()\n    if data.get(\"code\") != 0:\n        logging.error(\"Failed to log in: %s\", data.get(\"msg\"))\n        print(f\"{data=}\")\n        return False\n\n    if data.get(\"api\"):\n        logging.debug(\"Setting base url to %s\", data.get(\"api\"))\n        self.base_url = data.get(\"api\")\n    self.token = json.dumps(data.get(\"data\"))\n    logging.debug(\"Done login, token: %s\", self.token)\n    return True\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.getDataPvoutput","title":"<code>getDataPvoutput()</code>","text":"<p>updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getDataPvoutput(\n    self,\n) -&gt; Dict[str, Union[str, float]]:  # pylint: disable=invalid-name\n    \"\"\"updates and returns the data necessary for a one-shot pvoutput upload\n    'd' : testdate.strftime(\"%Y%m%d\"),\n    't' : testtime.strftime(\"%H:%M\"),\n    'v2' : 500, # power generation\n    'v4' : 450,\n    'v5' : 23.5, # temperature\n    'v6' : 234.0, # voltage\n    \"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    # \"time\": \"10/04/2019 14:37:29\"\n    timestamp = datetime.strptime(self.data.get(\"info\", {}).get(\"time\"), \"%m/%d/%Y %H:%M:%S\")\n    data: Dict[str, Union[str, float]] = {}\n    data[\"d\"] = timestamp.strftime(\"%Y%m%d\")  # date\n    data[\"t\"] = timestamp.strftime(\"%H:%M\")  # time\n    data[\"v2\"] = self.getPVFlow()  # PV Generation\n\n    load_flow = self.getLoadFlow()\n    if isinstance(load_flow, list):\n        data[\"v4\"] = load_flow[0]  # power consumption\n    else:\n        data[\"v4\"] = load_flow\n    temp = self.get_inverter_temperature()\n    if isinstance(temp, list):\n        data[\"v5\"] = temp[0]  # inverter temperature\n    else:\n        data[\"v5\"] = temp\n\n    voltage = self.getVoltage()\n    if isinstance(voltage, list):\n        data[\"v6\"] = voltage[0]\n    else:\n        data[\"v6\"] = voltage\n    return data\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.getDayDetailedReadingsExcel","title":"<code>getDayDetailedReadingsExcel(export_date, timeout=10, filename=None)</code>","text":"<p>retrieves the detailed daily results of the given date as an Excel sheet, processing the Excel sheet is outside the scope of the current module, possible args: - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getDayDetailedReadingsExcel(\n    self,\n    export_date: date,\n    timeout: int = 10,\n    filename: Optional[str] = None,\n) -&gt; bool:\n    \"\"\"retrieves the detailed daily results of the given date as an Excel sheet,\n    processing the Excel sheet is outside the scope of the current module,\n    possible args:\n    - filename: the path where to write the output file, default \"./Plant_Power_{datestr}.xls\n    \"\"\"\n    datestr = export_date.strftime(\"%Y-%m-%d\")\n    if filename is None:\n        filename = f\"Plant_Power_{datestr}.xls\"\n    logging.debug(\"Will write data for %s to file: %s\", datestr, filename)\n\n    uri = \"v1/PowerStation/ExportPowerstationPac\"\n    # {\"api\":\"v2/PowerStation/ExportPowerstationPac\",\"param\":{\"date\":\"2021-12-20\",\"pw_id\":\"&lt;my-pw-id&gt;\"\n    payload_export = {\n        \"date\": datestr,\n        \"pw_id\": self.system_id,\n    }\n\n    data = self.call(uri, payload=payload_export)\n\n    payload_get_url = {\"id\": data}\n    get_url_uri = \"v1/ReportData/GetStationPowerDataFilePath\"\n    data = self.call(get_url_uri, payload=payload_get_url)\n\n    file_url = data.get(\"file_path\")\n    if file_url is None:\n        logging.error(\"Failed to get file path from \")\n        return False\n\n    response = requests.get(file_url, timeout=timeout)\n    response.raise_for_status()\n\n    try:\n        file_download_path = Path(filename)\n        file_download_path.write_bytes(response.content)\n    except Exception as error_message:  # pylint: disable=broad-except\n        logging.error(\"Failed to write file %s! Error: %s\", filename, error_message)\n        return False\n    return True\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.getLoadFlow","title":"<code>getLoadFlow()</code>","text":"<p>returns the list of inverter multi-unit load watts</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getLoadFlow(self) -&gt; Union[List[float], float]:  # pylint: disable=invalid-name\n    \"\"\"returns the list of inverter multi-unit load watts\"\"\"\n    raise NotImplementedError(\"multi-unit load watts isn't implemented yet\")\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.getPVFlow","title":"<code>getPVFlow()</code>","text":"<p>PV flow data</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getPVFlow(self) -&gt; float:  # pylint: disable=invalid-name\n    \"\"\"PV flow data\"\"\"\n    raise NotImplementedError(\"SingleInverter has this, multi does not\")\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.getPmeter","title":"<code>getPmeter()</code>","text":"<p>gets the current line pmeter</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getPmeter(self) -&gt; float:  # pylint: disable=invalid-name\n    \"\"\"gets the current line pmeter\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return float(self.data.get(\"inverter\", {}).get(\"invert_full\", {}).get(\"pmeter\"))\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.getVoltage","title":"<code>getVoltage()</code>","text":"<p>returns the a list of the first AC channel voltages</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getVoltage(self) -&gt; Union[List[float], float]:  # pylint: disable=invalid-name\n    \"\"\"returns the a list of the first AC channel voltages\"\"\"\n    if not self.data:\n        self.getCurrentReadings(True)\n    if \"inverter\" not in self.data:\n        raise ValueError(\"Couldn't get data...\")\n    return [float(inverter.get(\"invert_full\", {}).get(\"vac1\")) for inverter in self.data[\"inverter\"]]\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.get_batteries_soc","title":"<code>get_batteries_soc()</code>","text":"<p>return the battery state of charge</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_batteries_soc(self) -&gt; Union[List[float], float]:\n    \"\"\"return the battery state of charge\"\"\"\n    return self._get_batteries_soc()\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.get_current_readings","title":"<code>get_current_readings(raw=True, retry=1, maxretries=5, delay=30)</code>","text":"<p>gets readings at the current point in time</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_current_readings(\n    self,\n    raw: bool = True,\n    retry: int = 1,\n    maxretries: int = 5,\n    delay: int = 30,\n) -&gt; Dict[str, Any]:  # pylint: disable=invalid-name\n    \"\"\"gets readings at the current point in time\"\"\"\n    payload = {\"powerStationId\": self.system_id}\n\n    # GOODWE server\n    self.data = self.call(\"v2/PowerStation/GetMonitorDetailByPowerstationId\", payload)\n\n    retval = self.data\n\n    if not self.data.get(\"inverter\"):\n        if retry &lt; maxretries:\n            logging.error(\"no inverter data, try %s, trying again in %s seconds\", retry, delay)\n            time.sleep(delay)\n            return self.get_current_readings(raw=raw, retry=retry + 1, maxretries=maxretries, delay=delay)\n        logging.error(\"No inverter data after %s retries, quitting.\", retry)\n        sys.exit(f\"No inverter data after {retry} retries, quitting.\")\n    return retval\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.get_inverter_temperature","title":"<code>get_inverter_temperature()</code>","text":"<p>returns the list of inverter temperatures</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_inverter_temperature(self) -&gt; Union[List[float], float]:\n    \"\"\"returns the list of inverter temperatures\"\"\"\n    if not self.data:\n        self.get_current_readings(True)\n    if \"inverter\" not in self.data:\n        raise ValueError(\"Couldn't get data...\")\n    return [float(inverter.get(\"invert_full\", {}).get(\"tempperature\")) for inverter in self.data[\"inverter\"]]\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.loaddata","title":"<code>loaddata(filename)</code>","text":"<p>loads a json file of existing data</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def loaddata(self, filename: str) -&gt; None:\n    \"\"\"loads a json file of existing data\"\"\"\n    with open(filename, \"r\", encoding=\"utf8\") as filehandle:\n        self.data = json.loads(filehandle.read())\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.API.parseValue","title":"<code>parseValue(value, unit)</code>  <code>classmethod</code>","text":"<p>takes a string value and reutrns it as a float (if possible)</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>@classmethod\ndef parseValue(cls, value: str, unit: str) -&gt; float:  # pylint: disable=invalid-name\n    \"\"\"takes a string value and reutrns it as a float (if possible)\"\"\"\n    try:\n        return float(value.rstrip(unit))\n    except ValueError as exp:\n        logging.warning(\"ValueError: %s\", exp)\n        return 0.0\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter","title":"<code>SingleInverter</code>","text":"<p>               Bases: <code>API</code></p> <p>API implementation for an account with a single inverter</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>class SingleInverter(API):\n    \"\"\"API implementation for an account with a single inverter\"\"\"\n\n    # pylint: disable=too-many-arguments\n    def __init__(\n        self,\n        system_id: str,\n        account: str,\n        password: str,\n        api_url: str = API_URL,\n        log_level: Optional[str] = None,\n        user_agent: str = DEFAULT_UA,\n        skipload: bool = False,\n    ) -&gt; None:\n        self.loadflow = 0.0\n        self.loadflow_direction = \"\"\n\n        self.data: Dict[str, Any]\n\n        # instantiate the base class\n        super().__init__(system_id, account, password, api_url, log_level, user_agent, skipload)\n\n    def loaddata(self, filename: str) -&gt; None:\n        \"\"\"loads the ata from a given file\"\"\"\n        self._loaddata(filename)\n        if self.data.get(\"inverter\"):\n            self.data[\"inverter\"] = self.data[\"inverter\"][0]\n\n    def get_current_readings(\n        self,\n        raw: bool = True,\n        retry: int = 1,\n        maxretries: int = 5,\n        delay: int = 30,\n    ) -&gt; Any:\n        \"\"\"grabs the data and makes sure self.data only has a single inverter\"\"\"\n\n        # update the data\n        super().get_current_readings(raw=raw, retry=retry, maxretries=maxretries, delay=delay)\n\n        # reduce self.data['inverter'] to a single dict from a list\n        if len(self.data.get(\"inverter\", [])) == 0:\n            logging.debug(\"No inverter data found in %s\", json.dumps(self.data))\n            raise ValueError(\"No inverter data found\")\n        self.data[\"inverter\"] = self.data[\"inverter\"][0]\n\n        return self.data\n\n    getCurrentReadings = get_current_readings\n\n    def _get_station_location(self) -&gt; Dict[str, Union[str, int]]:\n        \"\"\"gets the identified lat and long from the station data\"\"\"\n        return self.get_station_location()\n\n    def get_station_location(self) -&gt; Dict[str, Union[str, int]]:\n        \"\"\"gets the identified lat and long from the station data\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return {\n            \"latitude\": self.data.get(\"info\", {}).get(\"latitude\"),\n            \"longitude\": self.data.get(\"info\", {}).get(\"longitude\"),\n        }\n\n    def getPVFlow(self) -&gt; float:\n        \"\"\"returns the current flow amount of the PV panels\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        if self.data[\"powerflow\"][\"pv\"].endswith(\"(W)\"):\n            pvflow = self.data[\"powerflow\"][\"pv\"][:-3]\n        else:\n            pvflow = self.data[\"powerflow\"][\"pv\"]\n        return float(pvflow)\n\n    def getVoltage(self) -&gt; float:\n        \"\"\"gets the current line voltage\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return float(self.data[\"inverter\"][\"invert_full\"][\"vac1\"])\n\n    def get_day_income(self) -&gt; float:\n        \"\"\"gets the current daily income\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return float(self.data[\"kpi\"][\"day_income\"])\n\n    def get_total_income(self) -&gt; float:\n        \"\"\"gets the total income\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return float(self.data[\"kpi\"][\"total_income\"])\n\n    def get_total_power(self) -&gt; float:\n        \"\"\"gets the total power generated\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return float(self.data[\"kpi\"][\"total_power\"])\n\n    def get_day_power(self) -&gt; float:\n        \"\"\"gets the total power generated\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        return float(self.data[\"kpi\"][\"power\"])\n\n    def getLoadFlow(self) -&gt; float:\n        if not self.data:\n            self.getCurrentReadings()\n        if self.data[\"powerflow\"][\"bettery\"].endswith(\"(W)\"):\n            loadflow = float(self.data[\"powerflow\"][\"load\"][:-3])\n        else:\n            loadflow = float(self.data[\"powerflow\"][\"load\"])\n        # I'd love to see the *house* generate power\n        if self.data[\"powerflow\"][\"loadStatus\"] == -1:\n            loadflow_direction = \"Importing\"\n        elif self.data[\"powerflow\"][\"loadStatus\"] == 1:\n            loadflow_direction = \"Using Battery\"\n        else:\n            raise ValueError(f\"Your 'load' is doing something odd - status is '{self.data['powerflow']['loadStatus']}''.\")  # pylint: disable=line-too-long\n        self.loadflow = loadflow\n        self.loadflow_direction = loadflow_direction\n        return loadflow\n\n    def _get_batteries_soc(self) -&gt; float:\n        \"\"\"returns the state of charge of the battery\"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        if not self.data.get(\"soc\", False):\n            raise ValueError(\"No state of charge available from data\")\n        return float(self.data[\"soc\"].get(\"power\"))\n\n    def get_battery_soc(self) -&gt; float:\n        \"\"\"returns the single value state of charge for the batteries in the plant\n        returns : float\n        \"\"\"\n        return self._get_batteries_soc()\n\n    def get_inverter_temperature(self) -&gt; float:\n        if not self.data:\n            self.get_current_readings(True)\n        return float(self.data[\"inverter\"][\"tempperature\"])\n\n    def getDataPvoutput(\n        self,\n    ) -&gt; Dict[str, Union[str, float]]:  # pylint: disable=invalid-name\n        \"\"\"updates and returns the data necessary for a one-shot pvoutput upload\n        'd' : testdate.strftime(\"%Y%m%d\"),\n        't' : testtime.strftime(\"%H:%M\"),\n        'v2' : 500, # power generation\n        'v4' : 450,\n        'v5' : 23.5, # temperature\n        'v6' : 234.0, # voltage\n        \"\"\"\n        if not self.data:\n            self.getCurrentReadings()\n        # \"time\": \"10/04/2019 14:37:29\"\n        timestamp = datetime.strptime(self.data.get(\"info\", {}).get(\"time\"), \"%m/%d/%Y %H:%M:%S\")\n        data: Dict[str, Union[str, float]] = {}\n        data[\"d\"] = timestamp.strftime(\"%Y%m%d\")  # date\n        data[\"t\"] = timestamp.strftime(\"%H:%M\")  # time\n        data[\"v2\"] = self.getPVFlow()  # PV Generation\n        data[\"v4\"] = self.getLoadFlow()  # power consumption\n        data[\"v5\"] = self.get_inverter_temperature()  # inverter temperature\n        data[\"v6\"] = self.getVoltage()  # voltage\n        return data\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.getDataPvoutput","title":"<code>getDataPvoutput()</code>","text":"<p>updates and returns the data necessary for a one-shot pvoutput upload 'd' : testdate.strftime(\"%Y%m%d\"), 't' : testtime.strftime(\"%H:%M\"), 'v2' : 500, # power generation 'v4' : 450, 'v5' : 23.5, # temperature 'v6' : 234.0, # voltage</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getDataPvoutput(\n    self,\n) -&gt; Dict[str, Union[str, float]]:  # pylint: disable=invalid-name\n    \"\"\"updates and returns the data necessary for a one-shot pvoutput upload\n    'd' : testdate.strftime(\"%Y%m%d\"),\n    't' : testtime.strftime(\"%H:%M\"),\n    'v2' : 500, # power generation\n    'v4' : 450,\n    'v5' : 23.5, # temperature\n    'v6' : 234.0, # voltage\n    \"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    # \"time\": \"10/04/2019 14:37:29\"\n    timestamp = datetime.strptime(self.data.get(\"info\", {}).get(\"time\"), \"%m/%d/%Y %H:%M:%S\")\n    data: Dict[str, Union[str, float]] = {}\n    data[\"d\"] = timestamp.strftime(\"%Y%m%d\")  # date\n    data[\"t\"] = timestamp.strftime(\"%H:%M\")  # time\n    data[\"v2\"] = self.getPVFlow()  # PV Generation\n    data[\"v4\"] = self.getLoadFlow()  # power consumption\n    data[\"v5\"] = self.get_inverter_temperature()  # inverter temperature\n    data[\"v6\"] = self.getVoltage()  # voltage\n    return data\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.getPVFlow","title":"<code>getPVFlow()</code>","text":"<p>returns the current flow amount of the PV panels</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getPVFlow(self) -&gt; float:\n    \"\"\"returns the current flow amount of the PV panels\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    if self.data[\"powerflow\"][\"pv\"].endswith(\"(W)\"):\n        pvflow = self.data[\"powerflow\"][\"pv\"][:-3]\n    else:\n        pvflow = self.data[\"powerflow\"][\"pv\"]\n    return float(pvflow)\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.getVoltage","title":"<code>getVoltage()</code>","text":"<p>gets the current line voltage</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def getVoltage(self) -&gt; float:\n    \"\"\"gets the current line voltage\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return float(self.data[\"inverter\"][\"invert_full\"][\"vac1\"])\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_battery_soc","title":"<code>get_battery_soc()</code>","text":"<p>returns the single value state of charge for the batteries in the plant returns : float</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_battery_soc(self) -&gt; float:\n    \"\"\"returns the single value state of charge for the batteries in the plant\n    returns : float\n    \"\"\"\n    return self._get_batteries_soc()\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_current_readings","title":"<code>get_current_readings(raw=True, retry=1, maxretries=5, delay=30)</code>","text":"<p>grabs the data and makes sure self.data only has a single inverter</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_current_readings(\n    self,\n    raw: bool = True,\n    retry: int = 1,\n    maxretries: int = 5,\n    delay: int = 30,\n) -&gt; Any:\n    \"\"\"grabs the data and makes sure self.data only has a single inverter\"\"\"\n\n    # update the data\n    super().get_current_readings(raw=raw, retry=retry, maxretries=maxretries, delay=delay)\n\n    # reduce self.data['inverter'] to a single dict from a list\n    if len(self.data.get(\"inverter\", [])) == 0:\n        logging.debug(\"No inverter data found in %s\", json.dumps(self.data))\n        raise ValueError(\"No inverter data found\")\n    self.data[\"inverter\"] = self.data[\"inverter\"][0]\n\n    return self.data\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_day_income","title":"<code>get_day_income()</code>","text":"<p>gets the current daily income</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_day_income(self) -&gt; float:\n    \"\"\"gets the current daily income\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return float(self.data[\"kpi\"][\"day_income\"])\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_day_power","title":"<code>get_day_power()</code>","text":"<p>gets the total power generated</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_day_power(self) -&gt; float:\n    \"\"\"gets the total power generated\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return float(self.data[\"kpi\"][\"power\"])\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_station_location","title":"<code>get_station_location()</code>","text":"<p>gets the identified lat and long from the station data</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_station_location(self) -&gt; Dict[str, Union[str, int]]:\n    \"\"\"gets the identified lat and long from the station data\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return {\n        \"latitude\": self.data.get(\"info\", {}).get(\"latitude\"),\n        \"longitude\": self.data.get(\"info\", {}).get(\"longitude\"),\n    }\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_total_income","title":"<code>get_total_income()</code>","text":"<p>gets the total income</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_total_income(self) -&gt; float:\n    \"\"\"gets the total income\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return float(self.data[\"kpi\"][\"total_income\"])\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.get_total_power","title":"<code>get_total_power()</code>","text":"<p>gets the total power generated</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def get_total_power(self) -&gt; float:\n    \"\"\"gets the total power generated\"\"\"\n    if not self.data:\n        self.getCurrentReadings()\n    return float(self.data[\"kpi\"][\"total_power\"])\n</code></pre>"},{"location":"pygoodwe/#pygoodwe.SingleInverter.loaddata","title":"<code>loaddata(filename)</code>","text":"<p>loads the ata from a given file</p> Source code in <code>pygoodwe/__init__.py</code> <pre><code>def loaddata(self, filename: str) -&gt; None:\n    \"\"\"loads the ata from a given file\"\"\"\n    self._loaddata(filename)\n    if self.data.get(\"inverter\"):\n        self.data[\"inverter\"] = self.data[\"inverter\"][0]\n</code></pre>"},{"location":"release/","title":"Doing a release","text":"<ol> <li>Commit things</li> <li>Ensure the version's bumped in <code>pyproject.toml</code></li> <li>Do the tag: <code>git tag -a v0.0.10 -m 'Lint all the things'</code></li> <li>Check the tag showed up: <code>git tag</code></li> <li>Check the tag: <code>git show v0.0.10</code></li> <li>Push the tag: <code>git push origin v0.0.10</code></li> <li>Draft a release on Github</li> <li>Publish to pypi: <code>uv publish --build</code></li> </ol>"}]}